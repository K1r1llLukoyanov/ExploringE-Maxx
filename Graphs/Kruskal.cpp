#include <bits/stdc++.h>
using namespace std;

/*
    Алгоритм Крускала для составления минимального оставного дерева O(N ^ 2 + M * Log(N))
    Мнимальное оставное дерево - граф, имеющий минимальный вес, то есть минимальную возможную сумму ребер, при этом граф
    остается связным, то есть, если в исходном графе можно было добраться от какой-то вершины до другой вершины, то
    в оставном дереве это условие должно сохраняться.

    Алгоритм основан на сортировке всех ребер по их весу и объединении множества вершин.
    Каждая вершина принадлежит какому-либо множеству вершин(изначально у каждой вершины свое множество).

    Мы последовательно берем ребро из отсортированного массива, проверяем находятся ли вершины на концах
    этого ребра в разных множествах. Если они принадлежат разным множествам, то мы прибавляем к сумму ребер значение
    веса данного ребра, добавляем ребро в множество ребер оставного дерева и объединяем два множества вершин.

    Множества вершин различаются по индексу.
    То есть у каждой вершины есть определенный индекс, если индексы совпадают - они принадлежат одному множеству.
    Слияние происходит с помощью замены все индексов вершин одного множества на индекс другого множества.
*/

void Kruskal()
{
    int m;                                  // количество ребер графа
    vector<pair<int, pair<int, int>>> g(m); // вес - вершина 1 - вершина 2

    int cost = 0;               // сумма всех ребер оставного дерева
    vector<pair<int, int>> res; // множество ребер оставного дерева

    sort(g.begin(), g.end()); // сортируем ребра
    vector<int> tree_id(n);   // множество вершин
    for (int i = 0; i < n; i++)
        tree_id[i] = i; // изначально у каждой вершины свое множество
    for (int i = 0; i < m; i++)
    {
        int v1 = g[i].second.first, v2 = g[i].second.second, l = g[v].first; // v1 - первая вершина, v2 - вторая вершина, l - вес ребра
        if (tree_id[v1] != tree_id[v2])                                      // если множества вершин отличаются
        {
            cost += l;
            res.push_back({v1, v2}); // добавляем ребро
            int old_id = tree_id[a], new_id = tree_id[b];
            for (int j = 0; j < n; j++)
            {
                if (tree_id[j] == old_id)
                    tree_id[j] = new_id; // заменяем индексы
            }
        }
    }
}

/*
    Алгоритм Крускала основанный на системе непересекающихся множеств (DSU) за время (M*Log(N))
*/

int dsu_root(vector<int> &dsu, int a)
{
    return dsu[a] == a ? a : dsu[a] = dsu_root(dsu, dsu[a]);
}

void dsu_unite(vector<int> &dsu, vector<int> &sizes, int a, int b)
{
    int a = dsu_root(dsu, a);
    int b = rsu_root(dsu, b);
    if (a != b)
    {
        if(sizes[a] < sizes[b])
            swap(a, b);
        dsu[b] = a;
        sizes[a] += sizes[b];
    }
}

void Kruskal_DSU()
{
    int m;                               // количество вершин
    vector<pair<int, pair<int, int>>> g; // Вес - Вершина 1 - Вершина 2
    int cost = 0;
    vector<pair<int, int>> res;
    vector<int> dsu(n);
    vector<int> sizes(n);
    for (int i = 0; i < n; i++)
    {
        dsu[i] = i;
        sizes[i] = 1;
    }
    for (int i = 0; i < m; i++)
    {
        int a = g[i].second.first, b = g[i].second.secind, l = g[i].first;
        if (dsu_root(a) != dsu_root(b))
        {
            cost += l; // добавление веса к сумме
            res.push_back({a, b}); // добавление ребра
            dsu_unite(dsu, sizes, a, b); // объединение множетсв вершин
        }
    }
}

int main()
{
    return 0;
}
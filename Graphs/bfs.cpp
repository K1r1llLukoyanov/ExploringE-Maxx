#include <bits/stdc++.h>
using namespace std;

//Алгоритм поиска в ширину

void bfs(vector<vector<int>> &vec, int s, int e)
{									   // vec - список смежных вершин, start - начальная вершина, end - конечная вершина
	int n = vec.size();				   // Количество вершин графа
	bool used[n];					   // посещенные вершины
	int path[n];					   // путь от s до e
	memset(used, false, sizeof(used)); // выставляем false во всех вершинах
	queue<int> q;					   // очередь вершин
	q.push(s);						   // s первая
	used[s] = true;					   // s считает уже посещенной с нее все начинается
	path[s] = -1;					   // до старт вершин в пути нет
	while (!q.empty())
	{					   // пока очередь не станет пустой (не останется вершин которые можно посетить)
		int v = q.front(); // вытаскиваем первый элемент очереди
		q.pop();
		for (auto u : vec[v])
		{ // смотрим соседей вершины
			if (!used[u])
			{					// если сосед не посещен
				q.push(u);		// добавляем его в конец очереди
				path[u] = v;	// мы пришли в вершину u из вершины v
				used[u] = true; // запоминаем что мы посетили вершину u
			}
		}
	}
	if (!used[e])
	{
		cout << "Path is not found!\n"; // за время обхода вершина не была посещена
	}
	else
	{
		cout << "Path is found: "; // путь найден
		while (e != -1)
		{					  // пока e != -1
			cout << e << " "; // вершины будут выводиться от end до start
			e = path[e];	  // каждый раз вытаскиваем предыдущую вершину
		}
	}
}

int main()
{
	vector<vector<int>> vec = {{1, 2, 3}, {2, 3}, {3, 4}, {1, 4}, {1}}; // список смежности
	bfs(vec, 0, 4);														// 4 2 0
	return 0;
}
